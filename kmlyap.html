<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gelişmiş Koordinat Dönüştürücü (Excel/NCN Destekli)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Proj4js for Coordinate Conversion -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.js"></script>
    <!-- SheetJS for Excel Reading -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; }
        canvas { background-image: radial-gradient(#e5e7eb 1px, transparent 1px); background-size: 20px 20px; }
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #c1c1c1; border-radius: 3px; }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 min-h-screen flex flex-col">

    <!-- Header -->
    <header class="bg-indigo-700 text-white p-4 shadow-md">
        <div class="container mx-auto flex justify-between items-center">
            <h1 class="text-xl font-bold flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7" />
                </svg>
                Koordinat KML Çizici
            </h1>
            <span class="text-xs bg-indigo-800 px-2 py-1 rounded border border-indigo-600">Excel, NCN & TXT</span>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-grow container mx-auto p-4 flex flex-col lg:flex-row gap-6">
        
        <!-- Left Column: Input & Settings -->
        <div class="w-full lg:w-1/3 flex flex-col gap-4">
            
            <!-- Settings Panel -->
            <div class="bg-white p-5 rounded-lg shadow-sm border border-gray-200">
                <div class="mb-4">
                    <label class="block text-xs font-semibold text-gray-500 mb-1">Giriş Formatı</label>
                    <div class="flex rounded-md shadow-sm" role="group">
                        <button type="button" onclick="setMode('geo')" id="btnGeo" class="flex-1 px-4 py-2 text-sm font-medium bg-indigo-600 border border-indigo-600 text-white rounded-l-lg hover:bg-indigo-700">Coğrafi (Lat/Lon)</button>
                        <button type="button" onclick="setMode('metric')" id="btnMetric" class="flex-1 px-4 py-2 text-sm font-medium bg-white border border-gray-300 text-gray-700 rounded-r-lg hover:bg-gray-50">Metrik (Y, X)</button>
                    </div>
                </div>

                <!-- Metric Settings (Hidden if Geo) -->
                <div id="metricSettings" class="space-y-3 p-3 bg-indigo-50 rounded border border-indigo-100 hidden">
                    <div>
                        <label class="block text-xs font-bold text-gray-600 mb-1">Sistem & Datum</label>
                        <div class="grid grid-cols-2 gap-2">
                            <select id="projWidth" onchange="updateZoneOptions()" class="w-full p-2 text-sm border border-gray-300 rounded">
                                <option value="6">6° (UTM)</option>
                                <option value="3">3° (TM)</option>
                            </select>
                            <select id="datumSelect" class="w-full p-2 text-sm border border-gray-300 rounded">
                                <option value="ITRF96">WGS84 / ITRF</option>
                                <option value="ED50">ED-50</option>
                            </select>
                        </div>
                    </div>
                    <div>
                        <label id="zoneLabel" class="block text-xs font-bold text-gray-600 mb-1">Zone / DOM</label>
                        <select id="zoneSelect" class="w-full p-2 text-sm border border-gray-300 rounded"></select>
                    </div>
                </div>

                <!-- NEW: Manual Point Entry Form -->
                <div class="mt-4 p-3 bg-gray-100 rounded-md border border-gray-200">
                    <h3 class="text-xs font-bold text-gray-700 mb-2">Tek Tek Nokta Girişi</h3>
                    <div class="grid grid-cols-5 gap-2">
                        <input type="text" id="manualName" placeholder="Ad (örn: P1)" class="col-span-1 p-2 border border-gray-300 rounded text-xs focus:ring-indigo-500 focus:border-indigo-500">
                        <input type="number" id="manualV1" placeholder="Y / Lat" class="col-span-2 p-2 border border-gray-300 rounded text-xs focus:ring-indigo-500 focus:border-indigo-500" step="any">
                        <input type="number" id="manualV2" placeholder="X / Lon" class="col-span-2 p-2 border border-gray-300 rounded text-xs focus:ring-indigo-500 focus:border-indigo-500" step="any">
                        <button onclick="addManualPoint()" class="col-span-5 bg-indigo-500 hover:bg-indigo-600 text-white py-1.5 rounded text-sm font-medium transition">
                            Listeye Ekle
                        </button>
                    </div>
                </div>
                <!-- END NEW FORM -->
            
                <div class="mt-4">
                    <label class="block text-sm font-semibold mb-1 text-gray-700 flex justify-between">
                        Koordinat Listesi
                        <span class="text-[10px] font-normal text-indigo-600 cursor-pointer hover:underline" onclick="document.getElementById('fileInput').click()">Dosya Yükle (.xlsx, .ncn, .txt)</span>
                    </label>
                    
                    <!-- File Input (Hidden) -->
                    <input type="file" id="fileInput" class="hidden" accept=".xlsx, .xls, .txt, .ncn, .xyz" onchange="handleFileSelect(event)">
                    
                    <!-- COORDINATE INPUT AREA: Height increased from h-32 to h-48 -->
                    <textarea id="coordsInput" class="w-full h-48 p-3 border border-gray-300 rounded-md font-mono text-sm focus:ring-2 focus:ring-indigo-500 focus:outline-none resize-none whitespace-pre placeholder-gray-400" placeholder="Lütfen koordinatlarınızı her satıra bir nokta gelecek şekilde yapıştırın.&#10;&#10;Metrik (UTM/TM) Örn (Nokta Adı, Y/Sağa, X/Yukarı):&#10;Kose1 500123.45 4500123.45&#10;Kose2 500200.00 4500200.00&#10;&#10;Coğrafi (Lat/Lon) Örn (Enlem, Boylam):&#10;41.015137 28.979530&#10;41.012345 28.981234"></textarea>
                </div>

                <div class="mt-3 flex flex-col gap-2 text-xs">
                    <label class="flex items-center gap-2 cursor-pointer bg-gray-50 p-2 rounded border hover:bg-gray-100">
                        <input type="checkbox" id="hasName" class="text-indigo-600 rounded w-4 h-4" checked>
                        <div class="flex flex-col">
                            <span class="font-medium">İlk Sütun Nokta Adı</span>
                            <span class="text-[10px] text-gray-500">Excel/NCN'de genelde ilk sütun isimdir.</span>
                        </div>
                    </label>
                    <label class="flex items-center gap-2 cursor-pointer bg-gray-50 p-2 rounded border hover:bg-gray-100">
                        <input type="checkbox" id="isSwap" class="text-indigo-600 rounded w-4 h-4">
                        <div class="flex flex-col">
                            <span class="font-medium">X/Y Yer Değiştir</span>
                            <span class="text-[10px] text-gray-500">NetCAD dosyaları genelde (Y, X) sırasındadır. Ters ise işaretleyin.</span>
                        </div>
                    </label>
                </div>

                <button onclick="processData()" class="w-full mt-4 bg-indigo-600 hover:bg-indigo-700 text-white py-3 px-4 rounded-md font-bold transition shadow-sm flex justify-center items-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664zM21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                    NOKTALARI İŞLE
                </button>
            </div>

            <!-- Drawing Controls -->
            <div id="drawingControls" class="hidden bg-white p-4 rounded-lg shadow-sm border-l-4 border-green-500">
                <h3 class="text-sm font-bold text-gray-800 mb-2">Çizim Araçları</h3>
                <div class="grid grid-cols-2 gap-2">
                    <button onclick="autoConnect()" class="bg-indigo-50 hover:bg-indigo-100 text-indigo-700 py-1.5 px-2 rounded text-xs font-medium border border-indigo-200">
                        Sırayla Birleştir
                    </button>
                    <button onclick="undoLast()" class="bg-yellow-50 hover:bg-yellow-100 text-yellow-700 py-1.5 px-2 rounded text-xs font-medium border border-yellow-200">
                        Geri Al
                    </button>
                    <button onclick="clearDrawing()" class="col-span-2 bg-red-50 hover:bg-red-100 text-red-700 py-1.5 px-2 rounded text-xs font-medium border border-red-200">
                        Çizimi Temizle
                    </button>
                </div>
            </div>
        </div>

        <!-- Right Column: Visualization -->
        <div class="w-full lg:w-2/3 flex flex-col gap-4">
            
            <div id="resultPanel" class="bg-white p-4 rounded-lg shadow-sm border border-gray-200 hidden h-full flex flex-col">
                <div class="flex justify-between items-center mb-2">
                    <h3 class="text-sm font-bold text-gray-800 flex items-center gap-2">
                        <span class="w-2 h-2 rounded-full bg-green-500 animate-pulse"></span>
                        Önizleme
                    </h3>
                    <div class="text-xs text-gray-500 bg-gray-100 px-2 py-1 rounded">
                        Seçilen: <span id="selectedCount" class="font-bold text-indigo-600">0</span>
                    </div>
                </div>
                
                <!-- Canvas Container -->
                <div class="relative border rounded bg-gray-50 overflow-hidden flex-grow min-h-[400px]" id="canvasContainer">
                    <canvas id="mapCanvas" class="w-full h-full block cursor-crosshair"></canvas>
                    
                    <!-- Floating hint -->
                    <div id="hoverHint" class="absolute pointer-events-none bg-black/80 text-white text-xs px-2 py-1.5 rounded hidden transform -translate-y-full -translate-x-1/2 z-20 mb-2 shadow-lg font-mono">
                        Nokta Adı
                    </div>
                    
                    <div class="absolute bottom-2 left-2 bg-white/90 px-2 py-1 text-[10px] text-gray-500 pointer-events-none rounded border border-gray-200 shadow-sm backdrop-blur-sm">
                        Sol Tık: Çizgi Çek | Sağ Tık/Sürükle: Gez
                    </div>
                </div>

                <!-- Footer Actions -->
                <div class="mt-4 flex flex-col sm:flex-row gap-4 items-center border-t pt-4">
                     <div class="w-full sm:w-auto flex-grow text-xs text-gray-500">
                        İşlenen veriyi Google Earth (KML) formatında indirin.
                     </div>
                    <div class="flex gap-2 w-full sm:w-auto">
                        <div class="flex flex-grow sm:flex-grow-0">
                            <input type="text" id="fileName" value="projem" class="w-full sm:w-40 p-2 border border-gray-300 rounded-l text-sm focus:outline-none focus:border-indigo-500">
                            <span class="bg-gray-100 border border-l-0 border-gray-300 p-2 rounded-r text-gray-500 text-sm">.kml</span>
                        </div>
                        <button onclick="downloadKML()" class="bg-green-600 hover:bg-green-700 text-white py-2 px-6 rounded text-sm font-medium transition flex items-center gap-2 whitespace-nowrap shadow-sm">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                            </svg>
                            İNDİR
                        </button>
                    </div>
                </div>
            </div>

            <!-- Empty State -->
            <div id="instructionPanel" class="bg-blue-50 border border-dashed border-blue-200 p-8 rounded-lg text-center h-full flex flex-col justify-center items-center text-blue-800/60 transition-colors"
                 ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event)">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 mb-4 opacity-30 pointer-events-none" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 13h6m-3-3v6m5 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 011.414.586l4 4a1 1 0 01.586 1.414V19a2 2 0 01-2 2z" />
                </svg>
                <p class="font-medium pointer-events-none">Excel, NCN veya TXT dosyanızı buraya sürükleyin</p>
                <p class="text-xs opacity-70 mt-1 pointer-events-none">veya manuel yapıştırıp "İşle" butonuna basın.</p>
            </div>

        </div>
    </main>

    <script>
        const canvas = document.getElementById('mapCanvas');
        const container = document.getElementById('canvasContainer');
        const ctx = canvas.getContext('2d');
        const hoverHint = document.getElementById('hoverHint');
        const instructionPanel = document.getElementById('instructionPanel');
        
        let parsedPoints = []; 
        let selectedIndices = []; 
        let currentMode = 'geo';
        let transformInfo = { scaleX: 1, scaleY: 1, minLon: 0, minLat: 0, w: 0, h: 0 };
        
        function init() {
            setMode('geo');
            updateZoneOptions();
            window.addEventListener('resize', () => {
                resizeCanvas();
                if(parsedPoints.length > 0) drawMap();
            });
        }

        // --- Manual Entry Logic (NEW) ---
        function addManualPoint() {
            const name = document.getElementById('manualName').value.trim() || 'Nokta';
            const v1 = document.getElementById('manualV1').value;
            const v2 = document.getElementById('manualV2').value;
            const coordsInput = document.getElementById('coordsInput');
            const hasNameChecked = document.getElementById('hasName').checked;

            if (!v1 || !v2 || isNaN(parseFloat(v1.replace(',', '.'))) || isNaN(parseFloat(v2.replace(',', '.')))) {
                alert("Lütfen geçerli Y/Lat ve X/Lon değerlerini girin.");
                return;
            }

            // Clean coordinates (replace comma with dot)
            const v1Clean = v1.replace(',', '.');
            const v2Clean = v2.replace(',', '.');

            let newLine = '';
            if (hasNameChecked) {
                newLine = `${name} ${v1Clean} ${v2Clean}`;
            } else {
                newLine = `${v1Clean} ${v2Clean}`;
            }

            // Append to textarea
            const currentContent = coordsInput.value.trim();
            if (currentContent.length > 0) {
                coordsInput.value = currentContent + '\n' + newLine;
            } else {
                coordsInput.value = newLine;
            }
            
            // Clear V1 and V2 fields and update the name placeholder for continuity
            document.getElementById('manualV1').value = '';
            document.getElementById('manualV2').value = '';
            
            // Increment ID in placeholder if it was a numerical default
            let currentName = document.getElementById('manualName').placeholder;
            let match = currentName.match(/\d+/);
            if(match) {
                let newId = parseInt(match[0]) + 1;
                document.getElementById('manualName').placeholder = `Ad (örn: P${newId})`;
            }
        }
        // --- END Manual Entry Logic ---


        // --- File Handling ---
        function handleDragOver(e) {
            e.preventDefault();
            e.stopPropagation();
            instructionPanel.classList.add('bg-blue-100', 'border-blue-400');
        }

        function handleDragLeave(e) {
            e.preventDefault();
            e.stopPropagation();
            instructionPanel.classList.remove('bg-blue-100', 'border-blue-400');
        }

        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            instructionPanel.classList.remove('bg-blue-100', 'border-blue-400');
            
            const files = e.dataTransfer.files;
            if(files.length > 0) {
                loadFile(files[0]);
            }
        }

        function handleFileSelect(e) {
            const files = e.target.files;
            if(files.length > 0) {
                loadFile(files[0]);
            }
            // Reset input so same file can be selected again
            e.target.value = '';
        }

        function loadFile(file) {
            const fileName = file.name.toLowerCase();
            const reader = new FileReader();

            if (fileName.endsWith('.xlsx') || fileName.endsWith('.xls')) {
                // Excel Logic
                reader.onload = function(e) {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, {type: 'array'});
                    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                    // Convert to text: Space separated
                    const text = XLSX.utils.sheet_to_json(firstSheet, {header:1})
                        .map(row => row.join(' '))
                        .join('\n');
                    
                    document.getElementById('coordsInput').value = text;
                    // Auto switch to Metric if numbers look large
                    detectAndSetMode(text);
                };
                reader.readAsArrayBuffer(file);
            } else {
                // Text/NCN Logic
                reader.onload = function(e) {
                    document.getElementById('coordsInput').value = e.target.result;
                    detectAndSetMode(e.target.result);
                };
                // Try reading as text (Windows-1254 for Turkish characters in older NCN files might be needed, but UTF-8 is standard now)
                reader.readAsText(file); 
            }
        }

        function detectAndSetMode(text) {
            // Simple heuristic: if we see large numbers (>1000), probably Metric
            const match = text.match(/\d{4,}/);
            if(match) {
                setMode('metric');
                document.getElementById('btnMetric').click();
            }
        }

        // --- Canvas Events ---
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('click', handleMouseClick);
        canvas.addEventListener('mouseleave', () => {
            hoverHint.classList.add('hidden');
            drawMap();
        });

        function resizeCanvas() {
            if (container.clientWidth > 0 && container.clientHeight > 0) {
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
            }
        }

        // --- Data Processing ---
        function processData() {
            const input = document.getElementById('coordsInput').value;
            const isSwap = document.getElementById('isSwap').checked;
            const hasName = document.getElementById('hasName').checked; 
            
            const lines = input.split(/\r?\n/);
            parsedPoints = [];
            selectedIndices = [];

            let sourceProj = null;
            if (currentMode === 'metric') {
                const width = document.getElementById('projWidth').value;
                const datum = document.getElementById('datumSelect').value;
                const zoneVal = parseInt(document.getElementById('zoneSelect').value);
                const ed50params = "+towgs84=-87,-98,-121,0,0,0,0";
                const ellps = datum === 'ED50' ? `+ellps=intl ${ed50params}` : "+ellps=GRS80";
                
                if (width === '6') {
                    sourceProj = `+proj=utm +zone=${zoneVal} ${ellps} +units=m +no_defs`;
                } else {
                    sourceProj = `+proj=tmerc +lat_0=0 +lon_0=${zoneVal} +k=1 +x_0=500000 +y_0=0 ${ellps} +units=m +no_defs`;
                }
            }

            lines.forEach((line, index) => {
                // Filter empty parts
                const parts = line.trim().split(/\s+/).filter(p => p.length > 0);
                if (parts.length < 2) return; 

                let pointName = (index + 1).toString();
                let v1Str, v2Str;

                // Heuristic: If hasName is checked, assume 1st col is name
                // If parts > 2, usually Name X Y or Name Y X
                if (hasName && parts.length >= 3) {
                    pointName = parts[0];
                    v1Str = parts[1];
                    v2Str = parts[2];
                } else {
                    v1Str = parts[0];
                    v2Str = parts[1];
                }

                let v1 = parseFloat(v1Str.replace(',', '.'));
                let v2 = parseFloat(v2Str.replace(',', '.'));

                if (isNaN(v1) || isNaN(v2)) return;

                let lat, lon;
                if (currentMode === 'metric') {
                    let easting = isSwap ? v2 : v1; 
                    let northing = isSwap ? v1 : v2;
                    try {
                        const converted = proj4(sourceProj, 'EPSG:4326', [easting, northing]);
                        lon = converted[0];
                        lat = converted[1];
                        if(!isFinite(lon) || !isFinite(lat)) return;
                    } catch (e) { return; }
                } else {
                    if (isSwap) { lon = v1; lat = v2; } 
                    else { lat = v1; lon = v2; }
                }
                
                if (lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180) {
                    parsedPoints.push({ lat, lon, id: pointName });
                }
            });

            if (parsedPoints.length === 0) {
                alert("Geçerli veri bulunamadı. Formatı kontrol edin.");
                return;
            }

            document.getElementById('instructionPanel').classList.add('hidden');
            document.getElementById('resultPanel').classList.remove('hidden');
            document.getElementById('drawingControls').classList.remove('hidden');

            resizeCanvas();
            calculateTransform();
            drawMap();
            updateStats();
        }

        // --- Canvas Logic ---
        function calculateTransform() {
            let minLat = 90, maxLat = -90, minLon = 180, maxLon = -180;
            parsedPoints.forEach(p => {
                if(p.lat < minLat) minLat = p.lat;
                if(p.lat > maxLat) maxLat = p.lat;
                if(p.lon < minLon) minLon = p.lon;
                if(p.lon > maxLon) maxLon = p.lon;
            });

            if (minLat === maxLat) { minLat -= 0.01; maxLat += 0.01; }
            if (minLon === maxLon) { minLon -= 0.01; maxLon += 0.01; }

            const latBuf = (maxLat - minLat) * 0.15;
            const lonBuf = (maxLon - minLon) * 0.15;
            
            transformInfo.minLat = minLat - latBuf;
            transformInfo.maxLat = maxLat + latBuf;
            transformInfo.minLon = minLon - lonBuf;
            transformInfo.maxLon = maxLon + lonBuf;
            transformInfo.w = canvas.width;
            transformInfo.h = canvas.height;
        }

        function project(lat, lon) {
            const t = transformInfo;
            const lonRange = (t.maxLon - t.minLon) || 1;
            const latRange = (t.maxLat - t.minLat) || 1;
            const x = ((lon - t.minLon) / lonRange) * t.w;
            const y = t.h - ((lat - t.minLat) / latRange) * t.h;
            return {x, y};
        }

        function getNearestPoint(mouseX, mouseY) {
            let nearestIdx = -1;
            let minStartDist = 15; 
            parsedPoints.forEach((pt, idx) => {
                const pos = project(pt.lat, pt.lon);
                const dist = Math.sqrt((pos.x - mouseX)**2 + (pos.y - mouseY)**2);
                if (dist < minStartDist) {
                    minStartDist = dist;
                    nearestIdx = idx;
                }
            });
            return nearestIdx;
        }

        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const idx = getNearestPoint(x, y);
            
            drawMap(); 

            if (idx !== -1) {
                const pt = parsedPoints[idx];
                const pos = project(pt.lat, pt.lon);
                
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 6, 0, Math.PI*2);
                ctx.strokeStyle = '#4F46E5'; 
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.fillStyle = 'rgba(79, 70, 229, 0.2)';
                ctx.fill();

                canvas.style.cursor = 'pointer';
                hoverHint.style.left = (x + rect.left) + 'px'; 
                hoverHint.style.top = (y + rect.top - 10) + 'px';
                hoverHint.innerText = pt.id; 
                hoverHint.classList.remove('hidden');
            } else {
                canvas.style.cursor = 'crosshair';
                hoverHint.classList.add('hidden');
            }
        }

        function handleMouseClick(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const idx = getNearestPoint(x, y);
            
            if (idx !== -1) {
                selectedIndices.push(idx);
                drawMap();
                updateStats();
            }
        }

        function drawMap() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (parsedPoints.length === 0) return;

            if (selectedIndices.length > 1) {
                ctx.beginPath();
                ctx.strokeStyle = '#2563EB'; 
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                const start = parsedPoints[selectedIndices[0]];
                const startPos = project(start.lat, start.lon);
                ctx.moveTo(startPos.x, startPos.y);

                for (let i = 1; i < selectedIndices.length; i++) {
                    const pt = parsedPoints[selectedIndices[i]];
                    const pos = project(pt.lat, pt.lon);
                    ctx.lineTo(pos.x, pos.y);
                }
                ctx.stroke();
            }

            parsedPoints.forEach((pt, idx) => {
                const pos = project(pt.lat, pt.lon);
                const isSelected = selectedIndices.includes(idx);
                
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 4, 0, Math.PI*2);
                if (isSelected) {
                    ctx.fillStyle = '#2563EB'; 
                } else {
                    ctx.fillStyle = '#EF4444'; 
                }
                ctx.fill();

                if (selectedIndices.length > 0) {
                    if (selectedIndices[0] === idx) {
                        ctx.fillStyle = '#111827';
                        ctx.font = 'bold 11px sans-serif';
                        ctx.fillText("Başla", pos.x + 8, pos.y + 4);
                    }
                    if (selectedIndices[selectedIndices.length-1] === idx && selectedIndices.length > 1) {
                        ctx.fillStyle = '#111827';
                        ctx.font = 'bold 11px sans-serif';
                        ctx.fillText("Son", pos.x + 8, pos.y + 4);
                    }
                }
            });
        }

        function autoConnect() {
            selectedIndices = parsedPoints.map((_, idx) => idx);
            drawMap();
            updateStats();
        }

        function clearDrawing() {
            selectedIndices = [];
            drawMap();
            updateStats();
        }

        function undoLast() {
            selectedIndices.pop();
            drawMap();
            updateStats();
        }

        function updateStats() {
            document.getElementById('selectedCount').innerText = selectedIndices.length;
        }

        function setMode(mode) {
            currentMode = mode;
            const btnGeo = document.getElementById('btnGeo');
            const btnMetric = document.getElementById('btnMetric');
            const metricSettings = document.getElementById('metricSettings');
            const manualV1 = document.getElementById('manualV1');
            const manualV2 = document.getElementById('manualV2');


            if (mode === 'geo') {
                btnGeo.className = "flex-1 px-4 py-2 text-sm font-medium bg-indigo-600 border border-indigo-600 text-white rounded-l-lg";
                btnMetric.className = "flex-1 px-4 py-2 text-sm font-medium bg-white border border-gray-300 text-gray-700 rounded-r-lg hover:bg-gray-50";
                metricSettings.classList.add('hidden');
                
                // Update manual input placeholders
                manualV1.placeholder = "Enlem (Lat)";
                manualV2.placeholder = "Boylam (Lon)";
            } else {
                btnMetric.className = "flex-1 px-4 py-2 text-sm font-medium bg-indigo-600 border border-indigo-600 text-white rounded-r-lg";
                btnGeo.className = "flex-1 px-4 py-2 text-sm font-medium bg-white border border-gray-300 text-gray-700 rounded-l-lg hover:bg-gray-50";
                metricSettings.classList.remove('hidden');
                
                // Update manual input placeholders
                manualV1.placeholder = "Y / Sağa (Easting)";
                manualV2.placeholder = "X / Yukarı (Northing)";
            }
        }

        function updateZoneOptions() {
            const width = document.getElementById('projWidth').value;
            const zoneSelect = document.getElementById('zoneSelect');
            zoneSelect.innerHTML = '';
            const list = width === '6' ? [35, 36, 37, 38] : [27, 30, 33, 36, 39, 42, 45];
            list.forEach(val => {
                const opt = document.createElement('option');
                opt.value = val;
                opt.innerText = width === '6' ? `Zone ${val}` : `DOM ${val}°`;
                if(val === 36 || val === 30) opt.selected = true;
                zoneSelect.appendChild(opt);
            });
        }

        function downloadKML() {
            const fileName = document.getElementById('fileName').value || 'koordinatlar';
            const exportIndices = selectedIndices.length > 0 ? selectedIndices : parsedPoints.map((_, i) => i);
            const isPath = selectedIndices.length > 1;

            let kml = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>${fileName}</name>
    <Style id="lineStyle">
      <LineStyle><color>ff0000ff</color><width>4</width></LineStyle>
    </Style>`;

            if (isPath) {
                kml += `
    <Placemark>
      <name>${fileName}_Rota</name>
      <styleUrl>#lineStyle</styleUrl>
      <LineString>
        <tessellate>1</tessellate>
        <coordinates>
`;
                exportIndices.forEach(idx => {
                    const pt = parsedPoints[idx];
                    kml += `          ${pt.lon},${pt.lat},0\n`;
                });
                kml += `        </coordinates>
      </LineString>
    </Placemark>`;
            }

            kml += `
    <Folder>
      <name>Noktalar</name>
`;
            parsedPoints.forEach(pt => {
                 kml += `      <Placemark>
        <name>${pt.id}</name>
        <Point><coordinates>${pt.lon},${pt.lat},0</coordinates></Point>
      </Placemark>\n`;
            });

            kml += `    </Folder>
  </Document>
</kml>`;

            const blob = new Blob([kml], {type: 'application/vnd.google-earth.kml+xml'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName + ".kml";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        init();
    </script>
</body>
</html>